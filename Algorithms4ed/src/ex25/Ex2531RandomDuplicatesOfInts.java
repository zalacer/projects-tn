package ex25;

import static java.lang.Math.*;
import static v.ArrayUtils.*;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.util.Arrays;
import java.util.Random;

/* p358
  2.5.31 Duplicates. Write a client that takes integers M, N and T as 
  command-line arguments, then uses the code given in the text to perform
  T trials of the following experiment: Generate N random int values 
  between 0 and M – 1 and count the number of duplicates. Run your program 
  for T = 10 and N = 10^3, 10^4, 10^5, and 10^6, with M = N/2, N and 2N.
  Probability theory says that the number of duplicates should be about
  (1 – e^-N/M). Print a table to help you confirm that your experiments 
  validate that formula.
  
  (1 – e^-N/M) can't be the correct formula for the probable number of duplicates 
  because it ranges from 0-1.
                                                              
  N(1 – e^-N/M) may be correct, however, since the number of unique integers
  ranging from 0 to M-1 generated by uniform sampling N times is 
  M*(1-pow(1-(1/M),N), I prefer to use N-M*(1-pow(1-(1/M),N) as the formula for 
  the predictd number of duplicates. (For derivations of this formula see
  https://math.stackexchange.com/questions/1386527/expected-amount-of-repeats-in-a-random-sequence-of-integers
  and https://math.stackexchange.com/questions/35791/birthday-problem-expected-number-of-collisions
  that are in this project at Ex2531ExpectedNumberOfRepeatsInARandomSequenceOfIntegers.pdf
  and Ex2531BirthdayProblemCollisions.pdf.
  
  Test results show Java's Random, SecureRandom and SecureRandom.getInstanceStrong 
  all generate the expected number of duplicates within a few percent and so are
  uniform random number generators.
    
 */

public class Ex2531RandomDuplicatesOfInts { 
  
  public static int duplicates(int[] z) {
    if (z == null || z.length < 2) return 0;
    Arrays.sort(z); int d = 0;
    for (int i = 0; i < z.length-1; i++) if (z[i] == z[i+1]) d++;
    return d;
  }
  
  public static int predict(int m, int n) {
    if (m < 1 || n < 1) throw new IllegalArgumentException(
        "predict: m and n must both be > 0");
    int unique = (int)floor(1.*m*(1.-pow(1.-(1./m),n)));
    return n - unique ;
  }
  
  public static int testPRNG(int m, int n, int t) {
    if (m < 1 || n < 1 || t < 1) throw new IllegalArgumentException(
        "testPRNG: m, n and t must all be > 0");
    Random r;
    int[] z = new int[n]; int[] y = new int[t];
    for (int i = 0; i < t; i++) {
      r = new Random(System.currentTimeMillis());
      for (int j = 0; j < n; j++) z[j] = r.nextInt(m);
      y[i] = duplicates(z); 
    }
    return (int)Math.round(mean(y));  
  }
  
  public static int testSRNG(int m, int n, int t) {
    if (m < 1 || n < 1 || t < 1) throw new IllegalArgumentException(
        "testSRNG: m, n and t must all be > 0");
    SecureRandom r = new SecureRandom();
    int[] z = new int[n]; int[] y = new int[t];
    for (int i = 0; i < t; i++) {
      for (int j = 0; j < n; j++) z[j] = r.nextInt(m);
      y[i] = duplicates(z); 
    }
    return (int)Math.round(mean(y));  
  }
  
  public static int testSecureRandomStrong(int m, int n, int t) {
    if (m < 1 || n < 1 || t < 1) throw new IllegalArgumentException(
        "testSRNG: m, n and t must all be > 0");
    SecureRandom r;
    try {
      r = SecureRandom.getInstanceStrong();
    } catch (NoSuchAlgorithmException e) {
      System.out.println("can't create SecureRandom strong instance");
      return -1;
    }
    int[] z = new int[n]; int[] y = new int[t];
    for (int i = 0; i < t; i++) {
      for (int j = 0; j < n; j++) z[j] = r.nextInt(m);
      y[i] = duplicates(z); 
    }
    return (int)Math.round(mean(y));  
  }
  
  public static void testPRNG(int t) {
    int[] na = {1000,10000,100000,1000000}; 
    int[] ma = new int[3]; int d, p; double e;
    System.out.println("PRNG duplicates vs. predicted "+t+" trials");
    System.out.println("N        M        duplicates  predicted  %difference");
    for (int i = 0; i < na.length; i++) {
      ma[0] = na[i]/2;  ma[1] = na[i]; ma[2] = 2*na[i];
      for (int j = 0; j < ma.length; j++) {
        d = testPRNG(ma[j], na[i], t);
        p = predict(ma[j], na[i]);
        e = (100.*d-p)/p - 100.;     
        System.out.printf("%-7d  %-7d  %-7d     %-7d    %+5.3f\n", na[i], ma[j], d, p, e);    
      }
    }
    System.out.println();
  }
  
  public static void testSRNG(int t) {
    int[] na = {1000,10000,100000,1000000}; 
    int[] ma = new int[3]; int d, p; double e;
    System.out.println("SRNG duplicates vs. predicted "+t+" trials");
    System.out.println("N        M        duplicates  predicted  %difference");
    for (int i = 0; i < na.length; i++) {
      ma[0] = na[i]/2;  ma[1] = na[i]; ma[2] = 2*na[i];
      for (int j = 0; j < ma.length; j++) {
        d = testSRNG(ma[j], na[i], t);
        p = predict(ma[j], na[i]);
        e = (100.*d-p)/p - 100.;     
        System.out.printf("%-7d  %-7d  %-7d     %-7d    %+5.3f\n", na[i], ma[j], d, p, e);    
      }
    }
    System.out.println();
  }
  
  public static void testSecureRandomStrong(int t) {
    int[] na = {1000,10000,100000,1000000}; 
    int[] ma = new int[3]; int d, p; double e;
    System.out.println("SecureRandomStrong duplicates vs. predicted "+t+" trials");
    System.out.println("N        M        duplicates  predicted  %difference");
    for (int i = 0; i < na.length; i++) {
      ma[0] = na[i]/2;  ma[1] = na[i]; ma[2] = 2*na[i];
      for (int j = 0; j < ma.length; j++) {
        d = testSecureRandomStrong(ma[j], na[i], t);
        if (d == -1) return;
        p = predict(ma[j], na[i]);
        e = (100.*d-p)/p - 100.;     
        System.out.printf("%-7d  %-7d  %-7d     %-7d    %+5.3f\n", na[i], ma[j], d, p, e);    
      }
    }
    System.out.println();
  }

  public static void main(String[] args) {
    
    testPRNG(10);
    testSRNG(10);
    testSecureRandomStrong(10);
   
/* 
    PRNG duplicates vs. predicted 10 trials
    N        M        duplicates  predicted  %difference
    1000     500      550         568        -4.169
    1000     1000     377         368        +1.446
    1000     2000     225         213        +4.634
    10000    5000     5642        5677       -1.617
    10000    10000    3661        3679       -1.489
    10000    20000    2137        2131       -0.718
    100000   50000    56744       56767      -1.041
    100000   100000   36869       36788      -0.780
    100000   200000   21247       21306      -1.277
    1000000  500000   567704      567668     -0.994
    1000000  1000000  367957      367880     -0.979
    1000000  2000000  212872      213062     -1.089
    
    SRNG duplicates vs. predicted 10 trials
    N        M        duplicates  predicted  %difference
    1000     500      569         568        -0.824
    1000     1000     366         368        -1.543
    1000     2000     206         213        -4.286
    10000    5000     5671        5677       -1.106
    10000    10000    3670        3679       -1.245
    10000    20000    2140        2131       -0.578
    100000   50000    56767       56767      -1.000
    100000   100000   36783       36788      -1.014
    100000   200000   21320       21306      -0.934
    1000000  500000   567633      567668     -1.006
    1000000  1000000  367830      367880     -1.014
    1000000  2000000  213245      213062     -0.914
    
    SecureRandomStrong duplicates vs. predicted 10 trials
    N        M        duplicates  predicted  %difference
    1000     500      571         568        -0.472
    1000     1000     365         368        -1.815
    1000     2000     217         213        +0.878
    10000    5000     5681        5677       -0.930
    10000    10000    3674        3679       -1.136
    10000    20000    2132        2131       -0.953
    100000   50000    56750       56767      -1.030
    100000   100000   36813       36788      -0.932
    100000   200000   21332       21306      -0.878
    
    Not showing SecureRandomStrong results for N = 1000000
    because it's too slow, however so far it seems to show
    show better uniformity than PRNG and SRNG.

*/    
  }

}


