package ex23;

import static v.ArrayUtils.par;
import static sort.Quicks.compareQuickSortDoubleAlgs;
import static sort.Quicks.findRuntimesAndBestCutoffs;
import static sort.Quicks.plotAvgRunTimesVsCutoffsLg;

@SuppressWarnings("unused")
public class Ex2325QuickSortWithCutoff2InsertionSort {

  /* p307  
  2.3.25 Cutoff to insertion sort. Implement quicksort with a cutoff to insertion sort
  for subarrays with less than M elements, and empirically determine the value of M for
  which quicksort runs fastest in your computing environment to sort random arrays of N
  doubles, for N = 10^3, 10^4, 10^5, and 10^6. Plot average running times for M from 0 
  to 30 for each value of M. Note : You need to add a three-argument sort() method to
  Algorithm 2.2 for sorting subarrays such that the call Insertion.sort(a, lo, hi) sorts
  the subarray  a[lo..hi] 
  
  Using sort.Quicks.findRuntimesAndBestCutoffs(0,30,100) to collect the data, it reported
  the best cutoffs are 23, 15, 18, and 18 for random double arrays of lengths 10^3, 10^4, 
  10^5, and 10^6. The average of these cutoffs is 18.5 so 18 or 19 would be a good cutoff
  to use on my platform. For each array length and cutoff from [0..30] an average runtime
  was obtained by accumulating the runtimes of sort.Quicks.quickCoM3T9F3v2(d,M,false) 
  executed 100 times and dividing by 100, where d is the array, M is the cutoff and false
  disables shuffling since the arrays were generated pseudo-randomly with a new seed every 
  trial. Here is the runtime data in milliseconds where in each of the following arrays of 
  length 31 the index is the value of the cutoff:

  array length 10^3:
  [1.12,0.42,0.36,0.94,1.7,1.65,1.81,1.6,1.34,0.89,0.1,0.12, 0.12,0.12,0.1,0.09,0.13,0.09,
    0.06,0.12,0.08,0.1,0.12,0.03,0.11,0.09,0.11,0.09,0.11,0.09,0.1]
  
  array length 10^4:
  [1.69,1.65,1.63,1.57,1.53,1.54,1.47,1.46,1.38,1.39,1.43,1.42,1.42,1.39,1.38,1.37,
    1.41,1.4,1.39,1.4,1.39,1.42,1.43,1.41,1.43,1.41,1.41,1.43,1.46,1.46,1.47]
  
  array length 10^5:
  [21.98,21.72,21.28,20.67,20.17,20.08,19.56,19.41,19.26,19.25,19.11,18.93,18.89,18.89,
    18.93,18.76,18.97,18.79,18.68,18.97,18.92,18.86,19.72,18.87,18.99,19.01,19.06,19.11,
    19.12,19.16,19.16]
  
  array length 10^6:
  [329.19,327.0,325.0,316.9,311.68,311.48,307.46,303.78,303.8,302.09,300.31,300.45,299.38,
    302.64,301.16,298.31,298.29,298.18,297.87,301.33,298.52,298.58,298.85,300.23,299.38,
    300.14,300.45,300.71,301.26,301.83,302.71]
  
  statistics from this data:
  
  arrayLength    min      max      mean     stddev  100.*(max-min)/min
      10^3       0.030    1.810    0.449    0.590   5933.333
      10^4       1.370    1.690    1.453    0.083     23.358
      10^5      18.680   21.980   19.428    0.868     17.666
      10^6     297.870  329.190  304.483    8.697     10.515
      
  The statistics shows that even for relatively large arrays the choice of cutoff
  can make more than 10% difference in runtime.
  
  However a doubling test comparing cutoff 9 to cutoff 19 shows a less dramatic but
  noticeable difference:
  
  (output from 
     compareQuickSortDoubleAlgs("quickVCoM3T9F3v2Cutoff9", "quickVCoM3T9F3v2Cutoff19", 100);)
  
    quickVCoM3T9F3v2Cutoff9 vs quickVCoM3T9F3v2Cutoff19 average times over 100 trials 
        for random Double arrays
   array length  quickCoM3T9F3v2Cutoff9   time/prev  quickCoM3T9F3v2Cutoff19  time/prev
         2^8                0.140                NA             0.150                NA
         2^9                0.140             1.000             0.150             1.000
        2^10                0.780             5.571             0.730             4.867
        2^11                3.150             4.038             2.900             3.973
        2^12                1.210             0.384             1.000             0.345
        2^13                1.260             1.041             1.250             1.250
        2^14                2.760             2.190             2.640             2.112
        2^15                5.520             2.000             5.320             2.015
        2^16               11.660             2.112            11.530             2.167
        2^17               26.630             2.284            26.230             2.275
        2^18               62.160             2.334            61.140             2.331
        2^19              140.350             2.258           138.940             2.272
        2^20              320.150             2.281           316.590             2.279
        2^21              719.190             2.246           712.000             2.249
        2^22             1671.740             2.324          1638.980             2.302

  A plot of the average running times for M from 0 to 30 for each value of M and each of
  the array lengths 10^3, 10^4, 10^5, and 10^6 can be generated by running 
  plotAvgRunTimesVsCutoffsLg() in main below.
  
  */ 
  
  public static void main(String[] args) {
    
    plotAvgRunTimesVsCutoffsLg();
    
    // the arguments of findRuntimesAndBestCutoffs are min cutoff, max cutoff and number
    // of trials and all are ints.
    
//    Object[] x = findRuntimesAndBestCutoffs(0,30,100); // this takes a while for 100 trials
//    par(x[0]); // this prints the best cutoffs for array lengths 10^3, 10^4, 10^5, and 10^6
//    double[][] runtimes = (double[][])x[1];
//    for (int i=0;i<runtimes.length;i++) par(runtimes[i]); // this prints the runtimes arrays
  }

}

