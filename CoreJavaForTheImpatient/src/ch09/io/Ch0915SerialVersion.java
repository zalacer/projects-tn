package ch09.io;

import static utils.DateTimeUtils.now;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.OutputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Arrays;

// 15. Continue the preceding exercise, but change the data representation of Point so
// that it stores the coordinates in an array. What happens when the new version tries to
// read a file generated by the old version? What happens when you fix up the
// serialVersionUID? Suppose your life depended upon making the new version
// compatible with the old. What could you do?

// When implementing the new V2 Point I incremented its serialVersionUID from 1 to 2
// as well as replacing its x and y fields with an int[2] array to hold their
// values. On attempting to deserialize a previously serialized V1 Point to a V2
// Point I got an InvalidClassException on the cast due to the different 
// serialVersionUID's, which are final in both Point versions. Then I changed the
// value of serialVersionUID in the new V1 Point class to 1, which is the same as the
// old V1 Point. This second attempt at deserializing a V1 point to a V2 Point did
// not throw an exception, but resulted in a V2 Point with c == null from a V1 Point 
// with x == 3.0 and y == 4.0. This is logical, because the V2 Point class has no
// x or y and the V1 class has no c. In order to fix this I wrote a custom readObject()
// method in the V2  class which sets x, y and c using c[0] = x and c[1] = y if
// the value of c was not in the serialized class or sets x and y from c if c was in
// the serialized class but not in the result class, so it can read from and convert
// to both the old and new Point classes. It would also be feasible to modify the new
// Point to make it exactly like the old one but with an added c array that's built
// from x and y, but suspect this wouldn't scale well for a large number of fields
// which also would probabaly justify a non-backwards compatible upgrade.

// Here are two alternatives for backwards compatibility. Both involve modifications
// to the new version of Point.
// 1st approach:
// In the new version of Point:
// 0. reset serialVersionUID to 1L
// 1. add back x and y instance variables
// 2. in only constructor set the array's elements, x and y consistently
// 3. in the x setter set x and the first element of the array
// 4. in the y setter set y and the second element of the array
// 5. write an array setter and use it to resotre the array after deserialization 
// 6. to allow comparison of old and new instances restore the original equals, 
//    hashCode and toString methods which depend only x and y

// 2nd approach:
// In the new version of Point:
// Implement a custom readObject method in Point that fully accomodates both
// its versions, the first with double valued x and y instance variables and the
// second with a double[2] array named c. Using this method an array including 
// both versions of Point objects can be deserialized to either version. This 
// approach is flexible to accomodate a wide variety of changes in Point and 
// doesn't require a custom writeObject method. It has already been implemented
// in the new version of Point.

// In working on this exercise in Eclipse I found it easiest to move the original
// V1 Point.java out of package ch09.io instead of renaming it. For preparation
// it was necessary to have serialized V1 Point and V1 Point array instances.

// This class requires Point V2 which is named PointV2 in this package. To use
// use it first relocate both Point and PointV2 outside of this package. Then
// rename PointV2 to Point and move it back into this package.

public class Ch0915SerialVersion {
  
  private static String outputDir = "ser";

  public static void checkOutputDir() {
    File outDir = new File(outputDir);
    if (outDir.exists()) {
      if (!outDir.isDirectory()) {
        System.out.println(""
            + outputDir + " exists but it's not a directory, please remove"
            + "\nor rename it and create a directory named " + outputDir);
      }
    } else {
      boolean successful = outDir.mkdir();
      if (!successful) {
        System.out.println(""
            + "a directory named " + outputDir + " does not exist and could not be"
            + "\ncreated with mkdir. try creating it interactively");
      }
    }
  }

  public static String serializePoint(Point p) {
    long version = 2;
    String name = Point.class.getName();
    String opath = "ser\\" + name + "-V" + version + "-" +now() + ".ser";
    Path f = Paths.get(opath);
    OutputStream os = null;
    ObjectOutputStream oos = null;
    try {         
      os = Files.newOutputStream(f);
      oos = new ObjectOutputStream(os);
      oos.writeObject(p);
    } catch (IOException e) {
      e.printStackTrace();
    } finally {
      try {
        if (oos != null)
          oos.close();
      } catch (IOException e) {}
      try {
        if (os != null)
          os.close();
      } catch (IOException e) {}
    }
    return f.toString();
  }

  public static Object deSerialize(String f) {
    Object x = null;
    InputStream is = null;
    ObjectInputStream ois = null;
    try {         
      is = Files.newInputStream(Paths.get(f));
      ois = new ObjectInputStream(is);
      x = ois.readObject();
    } catch (Exception e) {
      e.printStackTrace();
    } finally {
      try {
        if (ois != null)
          ois.close();
      } catch (IOException e) {}
      try {
        if (is != null)
          is.close();
      } catch (IOException e) {}
    }
    return x;
  }

  public static void main(String[] args) {

    // this program requires a directory for serialization output
    checkOutputDir();
    
    // serialize and deserialize a new Point
    Point p = new Point(1,3);
    System.out.println(p); // Point(c=[1.0, 3.0])
    String f1 = serializePoint(p);
    System.out.println("f1="+f1);
    // f1=ser\ch09.io.Point-V2-20160223223500868.ser
    Point pDeSer = (Point) deSerialize(f1);
    System.out.println(pDeSer); // Point(c=[1.0, 3.0])
    
    // deserialize a V1 Point
    Point pDeSerV1 = 
        (Point) deSerialize("ser\\ch09.io.Point-V1-20160223225400068.ser");
    System.out.println(pDeSerV1); //Point(c=[3.0, 4.0])
    
    // deserialize an array of V1 Points
    Point[] pDeSerV1Arr = 
        (Point[]) deSerialize("ser\\ch09.io.PointArray-V1-20160223210200406.ser");
    System.out.println(Arrays.toString(pDeSerV1Arr));
    // [Point(c=[1.0, 2.0]), Point(c=[3.0, 4.0]), Point(c=[5.0, 6.0])]

  }

}
