package ex13;

import static v.ArrayUtils.append;
import static v.ArrayUtils.box;
import static v.ArrayUtils.exists;
import static v.ArrayUtils.fillInt;
import static v.ArrayUtils.filter;
import static v.ArrayUtils.pa;
import static v.ArrayUtils.permutationStream;
import static v.ArrayUtils.range;
import static v.ArrayUtils.take;
import static v.ArrayUtils.toList;
import static v.ArrayUtils.unbox;
import static v.ArrayUtils.unique;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.stream.Stream;

import ds.Stack;

//  p170
//  1.3.45 Stack generability. Suppose that we have a sequence of intermixed push and
//  pop operations as with our test stack client, where the integers  0 ,  1 , ...,  N-1 in that
//  order (push directives) are intermixed with N minus signs (pop directives). Devise an
//  algorithm that determines whether the intermixed sequence causes the stack to under-
//  flow. (You may use only an amount of space independent of Nâ€”you cannot store the
//  integers in a data structure.) Devise a linear-time algorithm that determines whether a
//  given permutation can be generated as output by our test client (depending on where
//  the pop directives occur).
//  Solution: The stack does not overflow unless there exists an integer k such that the first
//  k pop operations occur before the first k push operations. If a given permutation can be
//  generated, it is uniquely generated as follows: if the next integer in the output permuta-
//  tion is in the top of the stack, pop it; otherwise, push it onto the stack. 

public class Ex1345StackGenerability {
  
  public static boolean underflow(int[] ia) {
    // given int[] ia of length 2N containing elements in the range 0-N
    // exclusive in increasing order while randomly intermixed with with 
    // N -1's, determine if processing them by a stack causes underflow 
    // when each element >= 0 is pushed into the stack and each -1 pops 
    // it. if underflow occurs return false else return true.
    if (ia == null || ia.length == 0 || ia.length % 2 != 0) 
      throw new IllegalArgumentException("stackUnderFlowTest: the array ia must "
          + "be non null and have length > 0 divisible by 2");
    int sum = 0;
    for (int i = 0; i < ia.length; i++) {
      if (ia[i] < 0) {
        sum--;
      } else sum++;
      if (sum < 0) return false;
    }
    return true;
  }
  
  public static boolean generability(int[] g, int[] b) {
    // determine in linear time if the sequence in g can be generated by processing
    // the sequence in b by a stack given the following conditions on g and b.
    // 1. g and b are both not null and have length > 0.
    // 2. the length of b is divisible by 2
    // 3. the elements of b consist of ints in the range 0-b.length/2 (exclusive*) in 
    //    increasing order and intermixed in any way with b.length/2 -1's.
    // 4. the stack processes each positive element in b as a directive to push it and
    //    each -1 as a pop directive.
    // 5. if the stack throws an exception or fails to reproduce the sequence in g, 
    //    false is returned, otherwise true is returned.
    // These conditions imply additional conditions on g such as its length cannot be
    // greater than b.length/2, it cannot contain any int not in the range 0-b.length/2
    // (exclusive*) nor can it contain any of them more than once.
    // * applied to a range 0-N, exclusive means it includes 0,...,N-1 but not N
    
    if (g == null || b == null || g.length < 1 || b.length < 1)
      throw new IllegalArgumentException("generability: g and b must both be non null "
          + " and have lengths > 0");
    if (b.length % 2 == 1) throw new IllegalArgumentException("generability: b.length "
        + "must be divisible by 2");
    if (!Arrays.equals(filter(b, e -> e == -1), fillInt(b.length/2, () -> -1))) 
      throw new IllegalArgumentException("generability: b must contains b.length/2 -1's");
    if (!Arrays.equals(filter(b, e -> e != -1), range(0, b.length/2)))
        throw new IllegalArgumentException("generability: b must contains each int in "
            + "the range 0-b.length (exclusive) exactly once and in increasing order");
    if (exists(g, e -> (e < 0 || e > b.length/2 - 1))) throw new IllegalArgumentException(
        "generability: g must contain only ints in the range 0-b.length/2 (exclusive)");
    if (unique(g).length < g.length) throw new IllegalArgumentException(
        "generability: g must not contain any duplicate element");
    
    if (g.length > b.length/2) return false;
    
    // this algorithm takes time at most porportional to b.length because it operates by 
    // traversing b and for each b it does a pop or push operation and it fails fast.
    Stack<Integer> s = new Stack<Integer>();
    int[] o = new int[b.length/2];
    int c = 0; // counter for pops
    for (int i = 0; i < b.length; i++)
      if (b[i] == -1) {
        try {
          o[c] = s.pop();
          if (g[c] != o[c]) {
            return false;
          } else c++;
        } catch (Exception e) {
          return false;
        } 
      } else s.push(b[i]);
    if (!Arrays.equals(g, take(o, c))) return false;
    return true;
  }
  
  public static int[][] findGenerators(int[] g) {
    // for int[] g meeting certain conditions return the shortest int[]s with
    //  elements that generate g when fed to a stack under certain conditions of
    // using generability(). several preliminary constraints are imposed on g 
    // which are a subset of those imposed on it by generability(). if no generator
    // is found return an int[][] with first row containing exactly 2*a.length -1's.
    // under the experimental conditions at most one generator may be found.
    
    if (g == null || g.length < 1)
      throw new IllegalArgumentException("findGenerator: g must be non null and have length > 0");
    if (exists(g, e -> (e < 0))) throw new IllegalArgumentException(
        "findGenerator: all elements in a must be > 0");
    if (unique(g).length < g.length) throw new IllegalArgumentException(
        "findGenerator: g must not contain any duplicate element");
    
    LinkedHashSet<List<Integer>> s = new LinkedHashSet<>();
    // an advantange of using stream to generate permutations is that it's easy on memory and
    // can accomodate more than Integer.MAX_VALUE elements and at least Long.MAX_VALUE, maybe 
    // more, however it cannot be stopped midway without killing its process. An alternative 
    // would be to iterate over a Collection<List<Integer>> or Collection<int[]>. Probably 
    // memory would completely fill before one of those reaches its max capacity.
    permutations(g.length).filter(
        x -> {
          int c = 0;
          // set nonnegative elements in x to values from 0 to N-1 in increasing order
          for (int i = 0; i < x.length; i++) if (x[i] >= 0) x[i] = c++;
          if (generability(g, x)) s.add(toList((Integer[]) box(x))); 
          return false;
        }).count();
    
    if (s.size() == 0) {
      int[][] q = new int[1][];
      q[0] = fillInt(2*g.length, () -> -1);
      return q;
    }
    int[][] o = new int[s.size()][];
    int c  = 0;
    for (List<Integer> l : s) o[c++] = (int[]) unbox(l.toArray(new Integer[0]));
    return o; 
  }
  
  public static void testPermutation(int[] a) {
    // this tests the operation of the algorithm mentioned in solution included in the
    // exercise statement. for each element in a if the stack (created below) isn't 
    // empty and contains the element at the top it pops else it pushes the element.
    // finally it prints the accumulated popped elements and the contents of the stack.
    List<Integer> list = new ArrayList<>();
    Stack<Integer> s = new Stack<Integer>();
    for (int i : a) {
      if (!s.isEmpty()) {
        if (s.peek() == i) {
          list.add(s.pop());
        } else s.push(i);
      } else s.push(i);
      System.out.println(s);
    }
    System.out.println("stack output:");
    System.out.println(list);
    System.out.println(s); 
  }
  
  public static void testPermutation2(int[] g) {
    // this tests stack operation  with a sequence g of length 2N containing a permutation
    // of 0,1,...,N-1 in increasing order randomly intermixed with N -1's where each
    // positive digit is pushed and each -1 causes a pop
    List<Integer> list = new ArrayList<>();
    Stack<Integer> s = new Stack<Integer>();
    for (int i : g) {
      if (i == -1) 
        try {
          list.add(s.pop());
        } catch (Exception e) {
          System.out.println(e.getClass().getSimpleName());
          break;
        }
      else s.push(i);
      System.out.println(s);
    }
    System.out.println("stack output:");
    System.out.println(list);
    System.out.println("final stack contents:");
    System.out.println(s); 
  }

  public static int[] runPermutation(int[] ia) {
    // given int[] ia of length 2N containing a permutation of 0,1,...,N-1 intermixed
    // with N -1's, determine if it causes underflow if each element >= 0 is pushed
    // into a stack and each -1 pops it. if underflow occurs immediately return false
    // else return true after the array has been fully processed.
    Stack<Integer> st = new Stack<Integer>();
    ArrayList<Integer> al = new ArrayList<>();
    for (int i = 0; i < ia.length; i++)
      if (ia[i] < 0) {
        try {
          al.add(st.pop());
        } catch (Exception e) {
          return new int[0];
        } 
      } else st.push(ia[i]);
    return (int[]) unbox(al.toArray(new Integer[0]));
  }

  public static Stream<int[]> permutations(int N) {
    // return Stream of all permutations of int[]'s of size 2N containing one
    // N 1's and N -1's.  The 1's will be converted to the sequence 0 to N-1
    // in each array in stackTest.
    return permutationStream(append(fillInt(N, () -> 1), fillInt(N, () -> -1)));
  }

  public static HashSet<List<Integer>> stackTest(int N) {
    // return a set containing all allowed output permutations from a stack for
    // all input permutations of 1 to N-1 (inclusive) and N -1's, where the order
    // of nonnegative elements is preserved and where the stack pushes nonnegative
    // elements and executes pop() for negative elements.
    if (N < 0) throw new IllegalArgumentException("stackTest: N must be > 0");
    if (2*N > 20) throw new IllegalArgumentException("stackTest: use the BigInteger version");
    HashSet<List<Integer>> set = new HashSet<>();
    permutations(N).filter(
        x -> {
          int c = 0;
          // set nonnegative elements in x to values from 0 to N-1 in increasing order
          for (int i = 0; i < x.length; i++) if (x[i] >= 0) x[i] = c++;
          int[] a = runPermutation(x);
          if (a.length > 0) set.add(toList((Integer[]) box(a)));  
          return false;
        }).count();
    return set;
  }
  
  public static void main(String[] args) {
    
//    testPermutation2(new int[]{0,1,2,3,-1,-1,4,-1,-1,-1});
    //  this shows the contents of the stack are always in decreasing order
    //  Stack(0)
    //  Stack(1,0)
    //  Stack(2,1,0)
    //  Stack(3,2,1,0)
    //  Stack(2,1,0)
    //  Stack(1,0)
    //  Stack(4,1,0)
    //  Stack(1,0)
    //  Stack(0)
    //  Stack()
    //  stack output:
    //  [3, 2, 4, 1, 0]
    //  final stack contents:
    //  Stack()
    
//    testPermutation2(new int[]{0,1,-1,2,3,-1,-1,4,-1,-1});
    //  this shows the contents of the stack are always in decreasing order
    //  Stack(0)
    //  Stack(1,0)
    //  Stack(0)
    //  Stack(2,0)
    //  Stack(3,2,0)
    //  Stack(2,0)
    //  Stack(0)
    //  Stack(4,0)
    //  Stack(0)
    //  Stack()
    //  stack output:
    //  [1, 3, 2, 4, 0]
    //  final stack contents:
    //  Stack()
    
    int[] t = new int[]{2,1,0};
    int[][] r = findGenerators(t);
    for (int[] i : r) pa(i,77,1,1);
    //[0,1,2,-1,-1,-1]
//    
//    t = new int[]{1,0,2};
//    r = findGenerators(t);
//    for (int[] i : r) pa(i,77,1,1);
//    //[0,1,-1,-1,2,-1]
//    
//    t = new int[]{2,0,1}; //forbidden triple
//    r = findGenerators(t);
//    for (int[] i : r) pa(i,77,1,1);
//    //[-1,-1,-1,-1,-1,-1] 
//    
//    t = new int[]{3, 2, 4, 1, 0};
//    r = findGenerators(t);
//    for (int[] i : r) pa(i,77,1,1);
//    //[0,1,2,3,-1,-1,4,-1,-1,-1]
//    
//    t = new int[]{3, 0, 4, 1, 2}; // forbidden triple 3, 0, 1
//    r = findGenerators(t);
//    for (int[] i : r) pa(i,77,1,1);
//    //[-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]
    
//    HashSet<List<Integer>> set;
//    
//    set = stackTest(3); 
//    System.out.println(set.size()); //5
//    for (List<Integer> l : set)  System.out.println(l);
    //  [2, 1, 0]
    //  [0, 1, 2]
    //  [1, 0, 2]
    //  [1, 2, 0]
    //  [0, 2, 1]
    // output shows [2, 0, 1] is a forbidden triple, the only
    // one in this case since 3! = 6
   
//    set = stackTest(4); 
//    System.out.println("\n"+set.size()); //14
//    for (List<Integer> l : set)  System.out.println(l);
    //  [1, 2, 0, 3]
    //  [0, 2, 1, 3]
    //  [2, 1, 0, 3]
    //  [0, 3, 2, 1]
    //  [0, 1, 2, 3]
    //  [2, 3, 1, 0]
    //  [1, 3, 2, 0]
    //  [0, 2, 3, 1]
    //  [0, 1, 3, 2]
    //  [1, 0, 2, 3]
    //  [3, 2, 1, 0]
    //  [1, 2, 3, 0]
    //  [1, 0, 3, 2]
    //  [2, 1, 3, 0]
    // output shows (3,1,2), (3,0,2), (3,0,1), (2,0,1) are forbidden
    
//    set = stackTest(5); 
//    System.out.println("\n"+set.size()); //42
//    for (List<Integer> l : set)  System.out.println(l);
    //  [1, 0, 4, 3, 2]
    //  [1, 0, 2, 3, 4]
    //  [3, 2, 1, 0, 4]
    //  [1, 3, 2, 0, 4]
    //  [0, 3, 4, 2, 1]
    //  [0, 2, 4, 3, 1]
    //  [0, 1, 3, 4, 2]
    //  [0, 1, 2, 4, 3]
    //  [0, 2, 1, 3, 4]
    //  [0, 3, 2, 4, 1]
    //  [4, 3, 2, 1, 0]
    //  [2, 3, 1, 0, 4]
    //  [0, 1, 4, 3, 2]
    //  [0, 1, 2, 3, 4]
    //  [2, 1, 3, 0, 4]
    //  [0, 3, 2, 1, 4]
    //  [1, 4, 3, 2, 0]
    //  [1, 2, 3, 4, 0]
    //  [1, 2, 0, 4, 3]
    //  [3, 4, 2, 1, 0]
    //  [3, 2, 4, 1, 0]
    //  [1, 0, 3, 4, 2]
    //  [1, 0, 2, 4, 3]
    //  [1, 2, 3, 0, 4]
    //  [1, 0, 3, 2, 4]
    //  [0, 2, 3, 4, 1]
    //  [0, 2, 1, 4, 3]
    //  [2, 3, 1, 4, 0]
    //  [0, 4, 3, 2, 1]
    //  [2, 4, 3, 1, 0]
    //  [2, 1, 3, 4, 0]
    //  [2, 1, 0, 4, 3]
    //  [2, 1, 4, 3, 0]
    //  [2, 1, 0, 3, 4]
    //  [2, 3, 4, 1, 0]
    //  [0, 2, 3, 1, 4]
    //  [0, 1, 3, 2, 4]
    //  [1, 3, 4, 2, 0]
    //  [1, 2, 4, 3, 0]
    //  [1, 2, 0, 3, 4]
    //  [3, 2, 1, 4, 0]
    //  [1, 3, 2, 4, 0]


  }



}
